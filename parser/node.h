/* This file is part of KDevelop
 *
 * Copyright (C) 2010 Miquel Sabat√© <mikisabate@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


#ifndef NODE_H_
#define NODE_H_


#ifdef __cplusplus
extern "C" {
#endif

/**
 * This enumeration contains all the available tokens
 * used by this parser. This values are important for the
 * tests, so don't touch it unless you are really aware of
 * its side effects.
 */
enum node_t {
    token_invalid = -1,
    token_whitespace = 0,   /* Not used anymore */
    token_comment = 1,      /* Not used anymore */
    token_plus,
    token_minus,
    token_mul,
    token_pow,
    token_div,
    token_mod,
    token_bit_and,
    token_bit_or,
    token_bit_xor,          /* 10 */
    token_kw_and,
    token_kw_or,
    token_kw_not,
    token_or,
    token_and,
    token_lshift,
    token_rshift,
    token_neg,
    token_not,
    token_unary_plus,       /* 20 */
    token_unary_minus,
    token_assign,
    token_op_assign,
    token_assoc,
    token_cmp,
    token_eq,
    token_neq,
    token_eqq,
    token_match,
    token_nmatch,           /* 30 */
    token_greater,
    token_geq,
    token_lesser,
    token_leq,
    token_dot2,
    token_dot3,
    token_ternary,
    token_if,
    token_unless,
    token_while,            /* 40 */
    token_until,
    token_case,
    token_when,
    token_up_begin,
    token_up_end,
    token_for,
    token_begin,
    token_rescue_arg,
    token_rescue,
    token_ensure,           /* 50 */
    token_object,
    token_numeric,
    token_symbol,
    token_body,
    token_function,
    token_module,
    token_class,
    token_singleton_class,
    token_super,
    token_string,           /* 60 */
    token_regexp,
    token_key,
    token_array,
    token_hash,
    token_block,
    token_method_call,
    token_heredoc,
    token_break,
    token_redo,
    token_retry,            /* 70 */
    token_next,
    token_return,
    token_yield,
    token_alias,
    token_defined,
    token_undef,
    token_array_value,
    token__end__,
    token_true,
    token_false,            /* 80 */
    token_nil,
    token_self,
    token_encoding,
    token_file,
    token_line,             /* 85 */
};


/**
 * This structure stores errors/warnings on the parsing.
 */
struct error_t {
    char *msg;
    int line, column;
    unsigned char warning : 1;
    struct error_t *next;
};

/**
 * This is the AST generated by the parser. It contains the tree
 * and some stats that make things easier to the program that is
 * using this parser.
 */
struct ast_t {
    struct node *tree;
    struct error_t *errors;
};

/**
 * This structure represents a position inside the document
 * that is being parsed.
 */
struct pos_t {
    int start_line, end_line;
    int start_col, end_col;
    unsigned long long offset;
};

/**
 * This structure defines a node
 * in the abstract syntax tree
 */
struct node {
/* Node info */
    int kind;
    int flags;
    char *name;
    void *context;

/* Node's position */
    struct pos_t pos;
    struct pos_t *comment;

/* Left/Right childs */
    struct node *l;
    struct node *r;

/* Condition expression */
    struct node *cond;

/* Ensure expression (Exception-AST only) */
    struct node *ensure;

/* List of inner statements */
    struct node *next;
    struct node *last;
};

/*
 * Although it's not used internally, maybe this is more comfortable
 * to the "outside" programmer ;)
 */
typedef struct node Node;

/**
 * This struct contains all the options that may be passed
 * to the parser.
 */
struct options_t {
    const char *path;
    char *contents;
};


/* Interface to the parser */

/**
 * Generate the AST of a given ruby file.
 *
 * @param opts The options passed to the parser.
 * @return an AST that represents the code.
 */
struct ast_t * rb_compile_file(struct options_t *opts);

/**
 * Free an ast_t.
 *
 * @param ra the ast_t you want to free.
 */
void rb_free(struct ast_t *ra);

/**
 * Get the name node.
 *
 * @param n The root node.
 */
struct node * rb_name_node(struct node *n);

/*
 * There are three ways to allocate a node. The simplest one is
 * alloc_node. If the node has also a conditional expression, we
 * should use alloc_cond. Moreover, if the node has an ensure statement,
 * we should use alloc_ensure.
 */
struct node * alloc_node(int kind, struct node *l, struct node *r);
struct node * alloc_cond(int kind, struct node *cond, struct node *l,
                         struct node *r);
struct node * alloc_ensure(int kind, struct node * l, struct node *r,
                           struct node *els, struct node *ensure);


/*
 * These functions play with the next and last attributes of a node.
 * They're useful to create or update a list of nodes or to concatenate
 * two different lists,
 */
struct node * create_list(struct node *head, struct node *tail);
struct node * update_list(struct node *head, struct node *tail);
struct node * concat_list(struct node *head, struct node *tail);
#define pop_list(head, tail) \
    (tail->last == NULL) ? update_list(head, tail) : create_list(head, tail)


/*
 * Auxiliar functions
 */

#ifdef BUILD_TESTS
void print_node(struct node *n);
void print_errors(struct error_t *errors);
#endif

void free_ast(struct node *n);
void free_errors(struct ast_t *ra);


/*
 * Auxiliar macros.
 */

#define get_last_expr(n) ((n->last) ? n->last : n)
#define is_valid(n) (n->pos.start_line >= 0)
#define is_rest_arg(n) (n->flags == 1)
#define is_block_arg(n) (n->flags == 2)
#define is_global_var(n) (n->flags == 3)
#define is_ivar(n) (n->flags == 4)
#define is_cvar(n) (n->flags == 5)
#define is_constant (n->flags == 6)
#define is_float(n) (n->flags == 1)
#define valid_children(n) (n->r && n->l)
#define is_super(n) (!n->l)
#define has_star(n) (n->flags == 1 || n->flags == 2)
#define is_just_a_star(n) (n->flags == 2)


#ifdef __cplusplus
}
#endif


#endif /* NODE_H_ */

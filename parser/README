README
======

Intro:

This is a bison-generated pure LALR parser. It's based on the MRI parser
but not in a "strong way". This parser has been designed to be small,
simple and yet powerful. Its code resides in four different files:
parser.y, node.h, node.c and main.c. The main.c file is conceived only for
testing purposes (see the section "Testing and Debugging the parser").
More important are the files node.h and node.c that, in short, define
what is a node and what can we (and the parser) do with nodes. Finally,
the parser.y file is the grammar of the parser. This is the parser in
its very basic shape. To see what this parser really looks like, we have
to generate three files: parser.h, parser.c and hash.c. The parser.{h, c}
files are generated by bison taking the grammar file as its input. The last,
(but not least) file to generate is hash.c and it's generated by gperf
taking the file tools/gperf.txt as its input. It contains a hash table that
is used by the parser to match keywords quickly. All these files can be
generated by executing the tools/generate.rb script.


The parser's interface:

Now let's talk about what kind of interface can this parser provide
to the programmer in order to make things easier. In general, the header
that make the parser visible to the programmer is node.h. It defines the
structures node and RubyAst, and the enumeration token_t. This is quite good,
but what the programmer wants to use are the following functions:

  RubyAst * rb_compile_file(const char * path, const char * contents);
  void rb_free(RubyAst * ra);

The former wants the path of a Ruby source code file and its contents. If you
just want this parser to retrieve the contents on its own, just pass NULL
as its second parameter. It will return the generated AST (RubyAst).
Once we don't need this AST anymore, we should call the function rb_free.


Testing and Debugging the parser:

When we execute the "ruby-parser" executable with a given ruby file,
it will output a set of numbers. So, let's see what you should do to
perform the tests. We're going to go inside the directory tools/
and execute the script suite.rb. This executes the parser debugging
utility ("ruby-parser") for each test inside the tests/ directory and
finally it makes a diff between the expected output and the one given by
the parser. We cannot execute a single test file, so if we really want to do
it, we just have to do it by hand executing the parser with the test file
as a parameter. As you will see, the output is a set of integers, and sometimes
some names between parenthesis. To make it more human-readable, there's the
script fancy.rb (also at the tools/ directory) that will translate those
integers into strings, showing their meaning.
But, what represents all those integers from the output ? In short,
it's the representation of an AST printed in pre-order. As you
will see, the parser tries to beautify this output by telling you if the
expression is a condition inside of, for example, a for statement, or it will
output "Root" and "Next" if there is a list of inner statements. Moreover, the
parser sometimes outputs names between parenthesis. Those names are variables,
the name of a function, a class, etc. Sadly, sometimes the output is scary
and a complete mess. In those cases, experience and patience
will be our friends ;)


Character encodings:

As stated before, this parser is meant to be simple and small. This means
that by now we only support UTF-8 encoding. This doesn't mean that
other encodings will never be supported by this parser, it's just that
the developers haven't had enough time to write the code. If you think
that you can handle the challenge of writing support for more encodings,
please feel free to get in touch with the developers of the plugin (see
the AUTHORS file).


And hopefully that's all. So, do you still have questions? In that case,
please don't be shy and get in touch with Miquel Sabat√© (mssola), the
responsible of this parser.

Have a nice day ;)


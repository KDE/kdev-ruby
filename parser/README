README
======

== Intro ==

This is a bison-generated pure LALR parser. It's based on the MRI parser.
This parser has been designed to be small, simple and yet powerful. Its code
resides in four different files: parser.y, node.h, node.c and main.c.
The main.c file is conceived only for testing purposes (see the section
"Testing and Debugging the parser"). More important are the files node.h and
node.c that, in short, define what is a node and what can we (and the parser)
do with nodes. Finally, the parser.y file is the grammar of the parser. This
is the parser in its very basic shape. To see what this parser really looks
like, we have to generate three files: parser.h, parser.c and hash.c.
The parser.{h, c} files are generated by bison taking the grammar file as its
input. The last, (but not least) file to generate is hash.c and it's generated
by gperf taking the file tools/gperf.txt as its input. It contains a hash table
that is used by the parser to match keywords quickly. The parser.{h, c} files
are generated by cmake. The hash.c file is generated with the tools/gperf.rb
script.

== The parser's interface ==

Now let's talk about what kind of interface can this parser provide
to the programmer in order to make things easier. In general, the header
that make the parser visible to the programmer is node.h. It defines the
structures node and RAst, and the enumeration token_t. This is quite good,
but what the programmer wants to use are the following functions:

  RubyAst * rb_compile_file(const char * path, const char * contents);
  void rb_free(RubyAst * ra);
  struct node * rb_name_node(struct node * n);

The former wants the path of a Ruby source code file and its contents. If you
just want this parser to retrieve the contents on its own, just pass NULL
as its second parameter. It will return the generated AST (RubyAst).
Once we don't need this AST anymore, we should call the function rb_free.
The last one is for convenience, it returns the name that represents
the given node.


== Testing and Debugging the Parser ==

ruby-parser:
    command line tool to output the AST, verbatim from bison,
    nodes are represented as numbers
    usage:
        cd <build directory>
        parser/ruby-parser <ruby file>
    to see the human-readable AST representation use tools/fancy.rb
        cd <build directory>
        parser/tests/fancy.rb <test filename>

To execute the test suite:
    cd <build directory>
    make && make install    # tests do not currently run without installation
    ruby parser/tests/parser_test.rb  (where ruby version < 1.9)

Test suite will show a diff for any test failure and ask whether you want to
accept the change. If yes, the change will be written to the test file as
reference output. If no, test will fail.

Additional options to test suite:
ruby parser/tests/parser_test.rb -- --no-interactive
    skips all questions and just reports failures
ruby parser/tests/parser_test.rb -- --autoaccept
    prints diffs and automatically accepts all changes

To run a single test:
    cd <build directory>
    make && make install    # tests do not currently run without installation
    ruby parser/tests/parser_test.rb -n test_<test file basename without extension>

To add a new test:
    - create a new test file under parser/tests/data/
    - cd <build directory>
    - make && make install
    - rerun test suite
        ruby parser/tests/parser_test.rb
    - review and accept the test output
    - copy test output (<testname>.txt file) from build dir to source dir
    - commit both test file and test output

Additional info on parser output:
What represents all those integers from the output ? In short,
it's the representation of an AST printed in pre-order. As you
will see, the parser tries to beautify this output by telling you if the
expression is a condition inside of, for example, a for statement, or it will
output "Root" and "Next" if there is a list of inner statements. Moreover, the
parser sometimes outputs names between parenthesis. Those names are variables,
the name of a function, a class, etc. Sadly, sometimes the output is scary
and a complete mess. In those cases, experience and patience
will be our friends ;)


== Character encodings ==

As stated before, this parser is meant to be simple and small. This means
that by now we only support UTF-8 encoding. This doesn't mean that
other encodings will never be supported by this parser, it's just that
the developers haven't had enough time to write the code. If you think
that you can handle the challenge of writing support for more encodings,
please feel free to get in touch with the developers of the plugin (see
the AUTHORS file).


And hopefully that's all. So, do you still have questions? In that case,
please don't be shy and get in touch with Miquel Sabat√© (mssola), the
responsible of this parser.

Have a nice day ;)


README
======

== Intro ==

This is a bison-generated pure LALR parser. It's based on the MRI parser.
This parser has been designed to be small, simple and yet powerful. Its code
resides in four different files: parser.y, node.h, node.c and main.c.
The main.c file is conceived only for testing purposes (see the section
"Testing and Debugging the parser"). More important are the files node.h and
node.c that, in short, define what is a node and what can we (and the parser)
do with nodes. Finally, the parser.y file is the grammar of the parser. This
is the parser in its very basic shape. To see what this parser really looks
like, we have to generate three files: parser.h, parser.c and hash.c.
The parser.{h, c} files are generated by bison taking the grammar file as its
input. The last, (but not least) file to generate is hash.c and it's generated
by gperf taking the file tools/gperf.txt as its input. It contains a hash table
that is used by the parser to match keywords quickly. The parser.{h, c} files
are generated by cmake. The hash.c file is generated with the tools/gperf.rb
script.


== Testing and Debugging the Parser ==

All the info on testing the parser can be found here in the following URL:
http://techbase.kde.org/Projects/KDevelop4/Ruby#Testing

Additional info on parser output:
What represents all those integers from the output ? In short,
it's the representation of an AST printed in pre-order. As you
will see, the parser tries to beautify this output by telling you if the
expression is a condition inside of, for example, a for statement, or it will
output "Root" and "Next" if there is a list of inner statements. Moreover, the
parser sometimes outputs names between parenthesis. Those names are variables,
the name of a function, a class, etc. Sadly, sometimes the output is scary
and a complete mess. In those cases, experience and patience
will be our friends ;)


== Character encodings ==

As stated before, this parser is meant to be simple and small. This means
that by now we only support UTF-8 encoding. This doesn't mean that
other encodings will never be supported by this parser, it's just that
the developers haven't had enough time to write the code. If you think
that you can handle the challenge of writing support for more encodings,
please feel free to get in touch with the developers of the plugin (see
the AUTHORS file).


And hopefully that's all. So, do you still have questions? In that case,
please don't be shy and get in touch with Miquel Sabaté Solà (mssola), the
responsible of this parser.

Have a nice day ;)


README
======

Intro:

This is a bison-generated pure LALR parser. It's based on the MRI parser
but not in a "strong way". This parser has been designed to be small,
simple and yet powerful. Its code resides in four different files:
parser.y, node.h, node.c and main.c. The main.c file is conceived only for
testing purposes (see the section "Testing and Debugging the parser").
More important are the files node.h and node.c that, in short, define
what is a node and what can we (and the parser) do with nodes. Finally,
the parser.y file is the grammar of the parser. This is the parser in
its very basic shape. To see what this parser really looks like, we have
to generate three files: parser.h, parser.c and hash.c. The parser.{h, c}
files are generated by bison taking the grammar file as its input. The last,
(but not least) file to generate is hash.c and it's generated by gperf
taking the file tools/gperf.txt as its input. It contains a hash table that
is used by the parser to match keywords quickly. All these files can be
generated by executing the tools/generate.rb script.


The parser's interface:

Now let's talk about what kind of interface can this parser provide
to the programmer in order to make things easier. In general, the headers
that make the parser visible to the programmer are: node.h and interface.h.
The former is the important one. It defines the structures node and RubyAst,
and the enumeration token_t. This is quite good, but what the programmer wants
to use are the following functions:

  RubyAst * rb_compile_file(const char * path);
  void rb_free(RubyAst * ra);

The former wants the path of a Ruby source code file and it will return the
generated AST (RubyAst). Once we don't want to use this AST anymore, we should
call the function rb_free. But, how can we use this RubyAst? Easy, it has two
fields: tree (which is the root node of the real AST) and errors (which is the
list of the errors that the parser have detected). The node structure is more
complex and it's a little bit tricky. Thus, to make things easier, we have
the file interface.h. This file defines some useful macros. For example, let's
say that we have the following Ruby source code:

  class A < B
  end

The following C code can handle this situation:

  RubyAst * ast = rb_compile_file("example.rb");
  struct node * n = ast->tree;
  if (is_class(n)) {
    printf("This is a class definition\n");
    printf("The name of the class is: %s\n", class_name(n));
    if (has_superclass(n))
      printf("The superclass' name is: %s\n", superclass(n));
  }

In this example we have supposed that there are no errors. Anyway, the previous
example shows us how intuitive it is: "compile" our example and, if it's a class,
show us some info about it.


Testing and Debugging the parser:

In order to test and debug the parser, we now have to consider the main.c
file. As you can see, there's the macro LIB, that will change the way the
debugging utility operates. You can make the following combinations:

  - LIB = 0  => default mode
  - LIB = 1  => lib mode

The lib mode is only useful to test the interface of the parser. You have
to pass the path of a ruby file as a parameter and it will output a generated
AST that represents all the file. However, if you really want to debug & test
the parser, the best way is default mode. The usage is the same as in lib mode
but now it outputs each statement of the source code as an independent AST.
This mode is important because is the one used to perform the tests of
the tests/ directory. Now let's see what you should do to perform the tests.
To do it we are going to go inside the directory tools/ and execute the
script suite.rb. This executes the parser debugging utility ("ruby-parser")
for each test inside the tests/ directory and finally it makes a diff between
the expected output and the one given by the parser. We cannot execute a single
test file, so if we really want to do it, we just have to do it by hand
executing the parser with the test file as a parameter. As you will see, the
output is a set of integers, and sometimes some names between parenthesis. To
make it more human-readable, there's the script fancy.rb (also at the tools/
directory) that will translate those integers into strings, showing their
meaning.
But, what represents all those integers from the output ? In short,
it's the representation of an AST printed in pre-order. Be aware that in
default mode each ruby statement is represented as an individual AST. As you
will see, the parser tries to beautify this output by telling you if the
expression is a condition inside of, for example, a for statement, or it will
output "Root" and "Next" if there is a list of inner statements. Moreover, the
parser sometimes outputs names between parenthesis. Those names are variables,
the name of a function, a class, etc. Sadly, sometimes the output is scary
and a complete mess. In those cases, experience and patience
will be our friends ;)


Character encodings:

As stated before, this parser is meant to be simple and small. This means
that by now we only support UTF-8 encoding. This doesn't mean that
other encodings will never be supported by this parser, it's just that
the developers haven't had enough time to write the code. If you think
that you can handle the challenge of writing support for more encodings,
please feel free to get in touch with the developers of the plugin (see
the AUTHORS file).


And hopefully that's all. So, do you still have questions? In that case,
please don't be shy and get in touch with Miquel Sabat√© (mssola), the
responsible of this parser.

Have a nice day ;)

